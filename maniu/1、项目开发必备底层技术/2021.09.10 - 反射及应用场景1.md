---
typora-root-url: ./notes_res
---

# 反射及应用场景1

> - 学习目标：
>   - 反射在内存上的原理，反射为什么耗性能、调用慢
>
> - 为什么要学习内存？
>   - 因为反射的原理就是从内存上找到对应的方法并执行的一个过程
> - android中不是字节码，是dex，dex是以arm指令运行的

## 1、内存角度讲java设计中为什么要设计class与object

为什么要有class和object？

1. 假如没有class（类信息），那么每个 “对象” 都有一份相同的 “类信息”，造成内存爆棚。
2. 假如没有object（对象），虽然节省了 “内存” ，但是会不安全。因为每一个对象都能轻易地改变另外一个对象信息（公共信息存在class里，差异信息存在object里），通过修改公共信息，从而改变了其他对象的信息。

> 联想 “方法区” 和 “堆区”：
>
> - class 是从代码加载过来的
> - class 存放在 “方法区”，object 存放在 “堆区”
> - 从 “方法区” 中实例化一个 “对象” 放到 “堆区”

## 2、java内存分为哪些部分，为什么java有堆区、方法区

### 1）java 内存分为五个部分

- 方法区（主存）
  - 类信息class、静态变量、全局变量、常量池、处理逻辑的指令集
- 堆（主存）
  - 对象实例、被所有线程共享的一块内存区域
- 虚拟机栈（高速缓存区）
  - 栈信息、方法的局部变量
  - 每次开一个线程都会创建一个虚拟机栈，线程私有化，生命周期与线程相同
  - 数据存放在 “高速缓存区”

- 本地方法栈（高速缓存区）
  - native方法

- 程序计数器
  - 监听cup执行到哪一句代码

>  - 执行引擎：将方法区中对应的方法的arm指令加载到栈区，而栈区位于高速缓存中，cpu在直接从高速缓存中读取arm指令，一条一条执行。
>
>  - java虚拟机是用C和C++写的，c: malloc (500M)

### 2）为什么虚拟机要设计方法区、堆区？

java语言最大的优势是不用程序员管理内存，Oracle为了管理java对象运行机制（生命周期）设计了方法区和堆区（谁来管理，当然还是C++来管理）。方法区和堆区的设立只是为了好管理（在linux系统，这些区域本身也不存在）。

> 假如没有方法区：每次创建对象都要从磁盘加载字节码，然后new出来，性能低下
>
> 加入没有堆区：每次创建都要加载一个对象，并携带对应的class，相当消耗内存

## 3、虚拟机给App的内存我们该怎么理解呢？

- android虚拟机在linux中的申请内存，可以理解为一次性malloc了一大块内存。而内存中就有方法区和堆区
- 开启一个App代表虚拟机malloc一次内存（比如50M）。如果运行10个App，那么就是500M。虚拟机占Linux内存总共有500M
- 虚拟机自己管理内部对象的分配，由于内存回收需要知道对象占多大空间，所以在分配对象时，除了对象本身我们看得见的字段外，还需要对象的描述信息
- klass 是android所有对象的源头

## 4、分析arm指令（dex指令）

> - 硬件读写速度比较：cpu > 高速缓存 > 主存
>   - 高速缓存速度跟cpu差不多，所以cpu可以直接跟高速缓存打交道
>   - 主存速度远远慢于cpu，所以必须通过高速缓存才能跟cpu打交道
> - 如何获取dex指令：java --> class --> dex
>   - java经过javac编译得到.class文件
>   - .class文件经过dex编译得到dex指令
> - dx命令路径：/Users/TaoWang/Library/Android/sdk/build-tools/26.0.2/dx

### 1）添加dx的临时环境变量

```java
// 添加 /Users/TaoWang/Library/Android/sdk/build-tools/26.0.2/ 到临时环境变量
$ export PATH=$PATH:/Users/TaoWang/Library/Android/sdk/build-tools/26.0.2/

// 执行dx命令，如果正确输入，说明环境配置正确
$ dx
```

### 2）java文件编译成class文件

```java
// 1、编辑 Person.java 文件
// 注意：放在根目录，不要有包名
public class Person {
    public void run() {
        Person person = new Person();
        person.test();
    }

    public void test() {
    }
}


// 2、将 Person.java 编译成 Person.class
// Build -> Mack Project 生成class文件：/builld/intermediates/javac/debug/classes/Person.class
```

### 3）将class文件转成dex指令

```java
// 1、进入到 Person.class 所在目录
$ cd /Users/TaoWang/Desktop/Demo/app/build/intermediates/javac/debug/classes 

// 2、生成Person.run的dex指令
// --dex：编译成dex
// --verbose：编译过程中打印信息
// --dump-to=wata.txt：输出到wata.txt
// --dump-method=Person.run：编译的是Person.run方法
// --verbose-dump Person.class：输入的类路径
$ dx --dex --verbose --dump-to=wata.txt --dump-method=Person.run --verbose-dump Person.class

// 3、wata.txt的完整内容如下：
// wata.txt 中存放的是Person.run的dex指令
Person.run:()V:
regs: 0002; ins: 0001; outs: 0001
  0000: code-address
  0000: local-snapshot
  0000: code-address
  0000: code-address
  0000: local-snapshot
  0000: local-start v1 "this": Person
  0000: code-address
  0000: code-address
  0000: local-snapshot
          v1 "this": Person
  0000: code-address
  0000: new-instance v0, Person // type@0000
  0002: code-address
  0002: code-address
  0002: local-snapshot
          v1 "this": Person
  0002: code-address
  0002: code-address
  0002: local-snapshot
          v1 "this": Person
  0002: code-address
  0002: invoke-direct {v0}, Person.<init>:()V // method@0000
  0005: code-address
  0005: code-address
  0005: local-snapshot
          v1 "this": Person
  0005: local-start v0 "person": Person
  0005: code-address
  0005: invoke-virtual {v0}, Person.test:()V // method@0002
  0008: code-address
  0008: code-address
  0008: local-snapshot
          v0 "person": Person
          v1 "this": Person
  0008: return-void
  0009: code-address
  debug info
    line_start: 3
    parameters_size: 0000
    0000: prologue end
    0000: line 3
    0005: line 4
    0005: +local v0 person Person
    0008: line 5
    end sequence
  source file: "Person.java"

// 4、删除wata.txt中的不重要信息后如下：
// 0000、0002、0005...0009 是程序计数器
// 删除掉的部分是 dex日志
Person.run:()V:
regs: 0002; ins: 0001; outs: 0001
  0000: new-instance v0, Person // type@0000
  0002: invoke-direct {v0}, Person.<init>:()V // method@0000
  0005: invoke-virtual {v0}, Person.test:()V // method@0002
  0008: return-void

```

### 4）解读dex指令（局部变量）

```java
public class Person {
    public void run() {
        Person person = new Person();
        person.test();
    }

    public void test() {
    }
}
```

```java
Person.run:()V:
regs: 0002; ins: 0001; outs: 0001

  // 这句指令的含义：
  // 实例化一个对象Person，用游标v0指向该对象
  //
  // 可以得出的结论：
  // 结论1：由于v0是局部变量，所以v0存放在栈区（高速缓存）中
  // 结论2：无论java变量名多么的长，编译成dex指令后是一样（可以试验得出）
  // 
  // 执行步骤：
  // 第一步：栈区中申明一个变量v0（栈区 - 高速缓存）
  // 第二步：会将Person.class加载进方法区（方法区 - 主存）
  // 第三步：在堆区实例化一个对象Person（堆区 - 主存）
  // 第四步：将v0指向Person对象
  0000: new-instance v0, Person // type@0000
  
  // 执行步骤：
  // 第一步：通过取地址符 {v0} 拿到堆区的Person对象
  // 第二步：调用对象的构造函数，初始化对象
  0002: invoke-direct {v0}, Person.<init>:()V // method@0000
  
  0005: invoke-virtual {v0}, Person.test:()V // method@0002
  0008: return-void
```

### 5）解读dex指令（全局变量）

```java
public class Person {
    private Person person;

    public void run() {
        person = new Person();
        person.test();
    }

    public void test() {
    }
}
```

```java
Person.run:()V:
regs: 0002; ins: 0001; outs: 0001
  
  // 执行步骤：
  // 1）在堆区实例化一个对象Person
  // 2）栈区申明一个变量v0
  // 3）v0指向对象Person
  0000: new-instance v0, Person // type@0000
  
  // 执行步骤：
  // 1）通过取地址符 {v0} 拿到堆区的对象Person
	// 2）调用对象的初始化方法
  0002: invoke-direct {v0}, Person.<init>:()V // method@0000
      
  // 注意：因为申明了一个全局变量Person，所以在方法区中有一个全局变量v1
  // 			- v0在栈区（高速缓存），指向Person对象
  // 			- Person对象在堆区（主存）
  // 			- v1在方法区（主存），在执行该行指令前暂无指向
  //
  // 执行步骤：
  // 1）把v0的值赋值给v1（此时v1的值就等于v0，由于v0指向Person对象，所以v1也指向Person对象）
  0005: iput-object v0, v1, Person.person:LPerson; // field@0000

  0007: iget-object v0, v1, Person.person:LPerson; // field@0000
  0009: invoke-virtual {v0}, Person.test:()V // method@0002
  000c: return-void
```

### 6）解读dex指令（局部返回）

```java
public class Person {
    public Person run() {
        Person person = new Person();
        return person;
    }
}
```

```java
Person.run:()LPerson;:
regs: 0002; ins: 0001; outs: 0001
  
  // 1）在堆区实例化一个Person对象
  // 2）在栈区申明一个v0变量
  // 3）v0指向Person对象
  0000: new-instance v0, Person // type@0000
  
  // 1）通过取地址符 {v0} 拿到堆区的对象Person
  // 2）调用对象的 <init> 初始化方法
  0002: invoke-direct {v0}, Person.<init>:()V // method@0000
    
  // 1）因为v0在高速缓存中，所以可以直接返回给cpu  
  0005: return-object v0
```

### 7）解读dex指令（全局返回）

<img src="/分析dex指令.jpg" alt="分析dex指令" style="zoom:60%;" />

```java
public class Person {
    private Person person;

    public Person run() {
        person = new Person();
        return person;
    }
}
```

```java
Person.run:()LPerson;:
regs: 0002; ins: 0001; outs: 0001
  
  // 1）在堆区实例化一个Person对象
  // 2）在栈区申明一个v0变量
  // 3）v0指向Person对象
  0000: new-instance v0, Person // type@0000
    
  // 1）通过取地址符 {v0} 拿到堆区的对象Person
  // 2）调用对象的 <init> 初始化方法
  0002: invoke-direct {v0}, Person.<init>:()V // method@0000
    
  // 注意：因为申明了一个全局变量Person，所以在方法区中有一个全局变量v1
  // 			- v0在栈区（高速缓存），指向Person对象
  // 			- Person对象在堆区（主存）
  // 			- v1在方法区（主存），在执行该行指令前暂无指向
  //
  // 1）把v0的值赋值给v1（此时v1的值就等于v0，由于v0指向Person对象，所以v1也指向Person对象）
  0005: iput-object v0, v1, Person.person:LPerson; // field@0000

	// 1）把v1的值赋值给v0（相当于代码 v0=v1 ）
	// 
	// 重点：那为什么不直接返回v0，而要多这一步操作呢？
	// 答：因为涉及到多线程，直接返回v0不安全。
	//    设想：假如直接返回v0时，此时v1被修改指向了另一个Person对象，而v0指向依旧是老的Person对象。
	//    因此cpu为了安全起见，会再读一遍v1的值（因为cpu不能直接拿到v1的值，所以需要把v1的值赋给v0）
  0007: iget-object v0, v1, Person.person:LPerson; // field@0000

  // 1）因为v0在高速缓存中，所以可以直接返回给cpu
  0009: return-object v0
```

## 5、从dex指令角度分析单例

```java
// 当发生指令重排是，会发生 RuntimeException，概率大概是一万分之一
// private static volatile Person instance;// 加volatile可以避免指令重排
public class Person {
    private static Person instance;

    public static Person getInstance() {
        if (instance == null) {
            synchronized (Person.class) {
                if (instance == null) {
                    instance = new Person();
                }
            }
        }
        return instance;
    }
}
```

```java
// Person.getInstance的指令集看不懂 😭😭😭

Person.getInstance:()LPerson;:
regs: 0002; ins: 0000; outs: 0001
  0000: sget-object v0, Person.instance:LPerson; // field@0000
  0002: if-nez v0, 0013 // +0011
  0004: const-class v1, Person // type@0000
  0006: monitor-enter v1
  0007: sget-object v0, Person.instance:LPerson; // field@0000
  0009: if-nez v0, 0012 // +0009
  000b: new-instance v0, Person // type@0000
  000d: invoke-direct {v0}, Person.<init>:()V // method@0000
  0010: sput-object v0, Person.instance:LPerson; // field@0000
  0012: monitor-exit v1
    
  0013: sget-object v0, Person.instance:LPerson; // field@0000
  0015: return-object v0
```

## 6、面试题：String str = new String("123")创建了几个对象？

```
String str = new String("123"); 创建了几个对象？

创建了两个对象。
"123"是字符串常量，字符串常量也是常量，常量存放在方法区。
str 是字符串对象，对象存放在堆区。
因此该行代码创建了两个对象。
```

## 7、为什么“对象方法调用的速度”远快于“反射方法调用的速度”

>  java中的方法，是有一系列的指令组成（java方法 = 指令集）

### 1）直接调用方法

```java
public class Person {
    public void run() {
        Person person = new Person();
        person.test();
        person.test2();
        person.test3();
        person.test4();
        person.test5();
    }

    public void test() {
    }
    public void test2() {
    }
    public void test3() {
    }
    public void test4() {
    }
    public void test5() {
    }
}
```

```java
Person.run:()V:
regs: 0002; ins: 0001; outs: 0001
  0000: new-instance v0, Person // type@0000
  0002: invoke-direct {v0}, Person.<init>:()V // method@0000
    
  // 从这里可以看出，每个方法的指令都有对应的存放地址（method@0002、method@0003...）
  // method@0002、method@0003...method@0006：这个就是“方法表”，“方法表”存放在“方法区”
  // Person.class中有多个方法，每个方法会被封装成一个个ArtMethod对象。一个个ArtMethod对象就组成了方法表。
  // 
  // 对象直接调用方法：可以通过该地址找到指令（无需匹配、对比、校验指令），因此调用就快
  0005: invoke-virtual {v0}, Person.test:()V // method@0002
  0008: invoke-virtual {v0}, Person.test2:()V // method@0003
  000b: invoke-virtual {v0}, Person.test3:()V // method@0004
  000e: invoke-virtual {v0}, Person.test4:()V // method@0005
  0011: invoke-virtual {v0}, Person.test5:()V // method@0006
    
  0014: return-void
```

### 2）反射调用方法

```java
public static void main(String[] args) {
    Class<?> clazz = null;
    try {
        for (int i = 0; i < 1000; i++) {
            // 这里有懒加载机制，所以仅仅第一次慢
            clazz = Class.forName("com.wata.demo.Person");
            // 这一步性能最差
          	// 因为反射需要：1）根据方法名找到对应的指令 
          	//						 2）匹配指令
          	//						 3）对比指令
          	//						 4）校验签名
            Method method = clazz.getMethod("test");
            method.invoke(null);
        }
    } catch (Exception e) {
        e.printStackTrace();
    }
}
```
