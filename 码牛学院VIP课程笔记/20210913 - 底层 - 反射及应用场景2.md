# 反射及应用场景2

> - new Thread是比较费性能的原因：
>   - 每次开一个线程都会创建一个虚拟机栈（栈在高速缓存区，大小为8k）。当线程执行结束后，又回销毁对应的虚拟机栈。因此new Thread的方式是比较费性能的。
>   - 虚拟机中的栈是有多个的，每一个线程都有一个自己的栈。
> - 假如一个cpu有四核，那么同一时间只能运行四个线程

## 1、验证android虚拟机的编译预处理

```java
// --------------------------------------------------
// 1、编写 Person.java
// --------------------------------------------------
// Person.java 放在根目录，不要有包名
public class Person {
    public int test(){
        int a = 100;
        int b = 200;
        return a + b;
    }
}

// --------------------------------------------------
// 2、javac 生成 Person.class 
// --------------------------------------------------
// Build -> Make Project, 生成Person.class文件
// Person.class路径：/builld/intermediates/javac/debug/classes/Person.class
public class Person {
    public Person() {
    }

    public int test() {
        int a = 100;
        int b = 200;
        return a + b;
    }
}

// --------------------------------------------------
// 3、将.class的某个方法编译成dex指令
// --------------------------------------------------
// 1）配置dx临时环境变量
$ export PATH=$PATH:/Users/TaoWang/Library/Android/sdk/build-tools/26.0.2/

// 2）进入到 Person.class 所在目录
$ cd /Users/TaoWang/Desktop/Demo/app/build/intermediates/javac/debug/classes 

// 3）执行dex编译命令，生成Person.test方法的dex指令
// --dex：编译成dex
// --verbose：编译过程中打印信息
// --dump-to=wata.txt：输出到wata.txt
// --dump-method=Person.run：编译的是Person.run方法
// --verbose-dump Person.class：输入的类路径
$ dx --dex --verbose --dump-to=wata.txt --dump-method=Person.test --verbose-dump Person.class

// 4）删减dex日志信息后，得到如下dex指令：
// 观察发现，直接返回了300，并没有进行计算（从而验证android虚拟机有编译预处理，JVM没有）
Person.test:()I:
regs: 0004; ins: 0001; outs: 0000
  0000: const/16 v0, #int 100 // #0064
  0002: const/16 v1, #int 200 // #00c8
  0004: const/16 v2, #int 300 // #012c
  0006: return v2
    
// --------------------------------------------------
// 4、该情况下，无法进行编译预处理
// --------------------------------------------------  
public class Person {
    public int test(int a, int b){
        return a + b;
    }
}

Person.test:(II)I:
regs: 0004; ins: 0003; outs: 0000
  0000: add-int v0, v2, v3
  0002: return v0
```

## 2、klass知识点

> - 安卓虚拟机源码 class_link.cc
>
> - klass 的信息都是从 class_link.cc 中来的

```java
// klass是java对象的描述信息（每一个java对象，都会有klass）
// klass 的 objectSize，是修饰对象在堆区中的大小，一个空对象在堆区中占8个字节（在不同版本的java虚拟机中，占用有所不同）
// klass 的 classSize，是修饰类信息在方法区中的大小，一个类信息在方法区中占180个字节（在不同版本的java虚拟机中，占用有所不同）

// --------------------------------------------------
// classSize、objectSize
// --------------------------------------------------

// klass 的 classSize = 180
// klass 的 objectSize = 8
public class Person {}

// --------------------------------------------------
// 成员变量（存放在堆区，属于对象信息）
// --------------------------------------------------

// klass 的 objectSize = 12（对象本身8个字节+int类型所占的4个字节）
public class Person {
    int x;
}

// klass 的 objectSize = 16（对象本身8个字节+double类型所占的8个字节）
public class Person {
    double x;
}

// --------------------------------------------------
// 静态变量（存放在方法区中，属于类信息）
// --------------------------------------------------

// klass 的 classSize = 184（类本身180个字节+int所占的4个字节）
public class Person {
    static int x;
}

// klass 的 classSize = 192（类本身180个字节+double所占的8个字节+内存对齐所占的4个字节）
// 注意：内存对齐可以简单理解成，能被8整除。（188不能被8整除，所以补齐4个字节）
public class Person {
    static double x;
}

// klass 的 classSize = 192（类本身180个字节+double所占的8个字节+int所占的4个字节）
public class Person {
    static double x;
    static int 9;
}

// --------------------------------------------------
// 方法（属于类信息）
// --------------------------------------------------

// classSize = 184（类本身180个字节 + 方法4个字节）
// 方法加载到方法区中
// 一个方法是一个 ArtMethod 引用（指向的是方法的地址）
public class Person {
    public void run() {}
}
```

## 3、内存角度看内存泄漏

```java
// --------------------------------------------------
// 内存泄漏
// --------------------------------------------------
public class MainActivity extends AppCompatActivity {
  
    class Person {}
    Person person;
  
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
   
        // 此时 person对象 的 objectSize = 12（本身的8个字节+4个字节是MainActivity的引用）
        // 因此会发生内存泄漏
        person = new Person();
        person.hashCode();
    }
}


// --------------------------------------------------
// 内存泄漏
// --------------------------------------------------
public class MainActivity extends AppCompatActivity {
  
    class Person {}
    static Person person;
  
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
      
        // 内存泄漏 造成的原因：长生命周期的对象持有短生命周期的对象      
        // 这里内存泄漏的原因分析：
        // 		person变量 被static修饰，因此存放在方法区，不会被销毁。
        // 		person变量 指向 堆区的person对象，堆区的person对象 持有 MainActivity对象，
        // 		因此 MainActivity对象 也不会被销毁，从而造成内存泄漏
        person = new Person();
        person.hashCode();
    }
}

// --------------------------------------------------
// 不会内存泄漏
// --------------------------------------------------
public class MainActivity extends AppCompatActivity {
  
    static class Person {}
    static Person person;
  
    @Override
    protected void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);
        setContentView(R.layout.activity_main);
      
        // 此时 person对象 的 objectSize = 8（本身的8个字节）
        person = new Person();
        person.hashCode();
    }
}
```

## 4、查看安卓虚拟机源码

安卓虚拟机源码 class_link.cc
