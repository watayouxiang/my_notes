# C语言基础

## 数据类型

<img src="002_C语言基础.assets/image-20220331203424822.png" alt="image-20220331203424822" style="zoom:50%;" />

## struct

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    unsigned int a;// 无符号正数
    int b;
} Person;

int main() {
    Person *person = malloc(sizeof(Person));
    person->a = 44;
    person->b = 22;
    printf("a = %d\n", person->a);
    printf("b = %d\n", person->b);
    return 0;
}
```

## 宏

```c
#define David  99// 宏变量
#define ADD(x,y) ((x)+(y))// 宏函数
```

## 指针

### 基本使用

```c
#include <stdio.h>

int main() {
    int a = 10;
    int *p;// 定义一个地址的变量
    p = &a;// 把a的地址赋值给p

    printf("p = %d\n", *p);
    return 0;
}
```

### 数组是特殊的指针

```c
#include <stdio.h>

int main() {
    int c[9] = {1, 2, 3, 4, 5, 6, 7, 8, 9};

    // 数组是一个比较特殊的指针
    printf("%d \n",c);// 首地址
    printf("%d \n",&c);// 首地址的地址，还是首地址
    printf("%d \n",&c[0]);// 取首地址值的地址

    printf("%d \n",*c);// 取首地址的值
    printf("%d \n",c[0]);// 取首地址的值
    printf("%d \n",*(c+1));// 取第二个地址的值
    
    return 0;
}
```

### 数组指针

```c
#include <stdio.h>

int main() {
    int a = 10;
    int b = 20;
    int c = 30;
    int *p1 = &a;
    int *p2 = &b;
    int *p3 = &c;
    int *arr[3] = {p1, p2, p3};// 数组指针：数组存放的是指针类型

    printf("%d \n", *arr[0]);// 10
    printf("%d \n", **arr);// 10

    return 0;
}
```

### 二维数组

```c
#include <stdio.h>

int main() {
    int a[] = {10, 20};																			
    int b[] = {30, 10};
    int c[] = {10};
    int *arr[3] = {a, b, c};// 二维数组

    printf("%d \n", **arr);
    printf("%d \n", arr[1][1]);

    return 0;
}
```

### 指针的类型（重要）

从语法的角度看，你只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。

让我们看看如下各个指针的类型：

```
(1) int *ptr; //指针的类型是int *

(2) char *ptr; //指针的类型是char *

(3) int **ptr; //指针的类型是int **

(4) int (*ptr)[3]; //指针的类型是int(*)[3]

(5) int *(*ptr)[4]; //指针的类型是int*(*)[4]
```

###  指针所指向的类型（重要）

当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。

从语法上看，你只须把指针声明语句中的指针名字和名字左边的指针声明符*去掉，剩下的就是指针所指向的类型。例如：

```
(1) int *ptr; //指针所指向的类型是int

(2) char *ptr; //指针所指向的的类型是char

(3) int **ptr; //指针所指向的的类型是int*

(4) int (*ptr)[3]; //指针所指向的的类型是int()[3]

(5) int *(*ptr)[4]; //指针所指向的的类型是int *()[4]
```

在指针的算术运算中，指针所指向的类型有很大的作用，他决定步长。

“指针的类型” 和 “指针所指向的类型” 是两个概念。当你对C 越来越熟悉时，你会发现，这个是精通指针的关键点之一。

### 异常指针

空悬指针：指针正常初始化，曾指向过一个正常的对象，但是对象销毁了，该指针未置空，就成了悬空指针。

野指针：未初始化的指针，其指针内容为一个垃圾数。存在野指针是一个严重的错误。

### 二级指针

#### 实现方法一

<img src="002_C语言基础.assets/image-20220331193709024.png" alt="image-20220331193709024" style="zoom:50%;" />

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int **ptr = NULL;
    int num = 4, size = 4, i, j;

    ptr = (int **) malloc(num * sizeof(int *));
    for (i = 0; i < num; ++i) {
        *(ptr + i) = (int *) malloc(size * sizeof(int));
        for (j = 0; j < size; ++j) {
            *(*(ptr + i) + j) = (i + 1) * j;
        }
    }

    for (i = 0; i < num; ++i) {
        for (j = 0; j < size; ++j) {
            printf("(%d, %d) -> %d;\t", i, j, *(*(ptr + i) + j));
        }
        printf("\n");
    }
    return 0;
}

// 输出如下：
// (0, 0) -> 0;		(0, 1) -> 1;		(0, 2) -> 2;		(0, 3) -> 3;	
// (1, 0) -> 0;		(1, 1) -> 2;		(1, 2) -> 4;		(1, 3) -> 6;	
// (2, 0) -> 0;		(2, 1) -> 3;		(2, 2) -> 6;		(2, 3) -> 9;	
// (3, 0) -> 0;		(3, 1) -> 4;		(3, 2) -> 8;		(3, 3) -> 12;
```

#### 实现方法二

<img src="002_C语言基础.assets/image-20220331202232429.png" alt="image-20220331202232429" style="zoom:50%;" />

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int **ptr = NULL;
    int num = 4, size = 4, i, j;

    ptr = (int **) malloc(num * sizeof(int *));
    for (i = 0; i < num; ++i) {
        ptr[i] = (int *) malloc(size * sizeof(int));
        for (j = 0; j < size; ++j) {
            ptr[i][j] = (i + 1) * j;
        }
    }

    for (i = 0; i < num; ++i) {
        for (j = 0; j < size; ++j) {
            printf("(%d, %d) -> %d;\t", i, j, ptr[i][j]);
        }
        printf("\n");
    }

    return 0;
}

// 输出如下：
// (0, 0) -> 0;    (0, 1) -> 1;   (0, 2) -> 2;   (0, 3) -> 3;
// (1, 0) -> 0;    (1, 1) -> 2;   (1, 2) -> 4;   (1, 3) -> 6;
// (2, 0) -> 0;    (2, 1) -> 3;   (2, 2) -> 6;   (2, 3) -> 9;
// (3, 0) -> 0;    (3, 1) -> 4;   (3, 2) -> 8;   (3, 3) -> 12;
```

## 内存分配

C语言的标准内存分配函数：malloc，calloc，realloc，free等。

- malloc(size): 在内存的动态存储区中分配一块长度为size字节的连续区域，返回该区域的首地址。
  - malloc只分配空间不初始化，也就是依然保留着这段内存里的数据。

- calloc(n, size)：在内存的动态存储区中分配n块长度为size字节的连续区域，返回首地址。
  - calloc分配的空间全部初始化为0。

- realloc(*ptr, size)：将ptr内存大小增大到size。

- free(void \*ptr)：释放ptr所指向的一块内存空间。

## 内存管理机制

​		**代码区：**程序被操作系统加载到内存的时候，所有的可执行代码(程序代码指令、常量字符串等)都加载到 代码区，这块内存在程序运行期间是不变的。代码区是平行的，里面装的就是一堆指令，在程序运行期 间是不能改变的。函数也是代码的一部分，故函数都被放在代码区，包括main函数。

​		**静态区：**静态区存放程序中所有的全局变量和静态变量。

​		**栈区：**栈(stack)是一种先进后出的内存结构，所有的自动变量、函数形参都存储在栈中，这个动作由编译器自动完成，我们写程序时不需要考虑。栈区在程序运行期间是可以随时修改的。当一个自动变量超出其作用域时，自动从栈中弹出。

每个线程都有自己专属的栈。栈的最大尺寸固定，超出则引起栈溢出。变量离开作用域后栈上的内存会自动释放。

​		**堆区：**堆和栈一样，也是一种在程序运行过程中可以随时修改的内存区域，但没有栈那样先进后出的顺序。更重要的是堆是一个大容器，它的容量要远远大于栈，这可以解决内存溢出困难。一般比较复杂的数据类型都是放在堆中。但是在C语言中，堆内存空间的申请和释放需要手动通过代码来完成。

malloc函数用来在堆中分配指定大小的内存，单位为字节(Byte)，函数返回void *指针。free负责在 堆中释放malloc分配的内存。

​		**什么时候用堆什么时候用栈呢？**一般遵循以下三个原则：

- 如果明确知道数据占用多少内存，那么数据量较小时用栈，较大时用堆。
- 如果不知道数据量大小(可能需要占用较大内存)，最好用堆(因为这样保险些)。
- 如果需要动态创建数组，则用堆。

​		操作系统在管理内存时，最小单位不是字节，而是**内存页**(32位操作系统的内存页一般是4K)。比如，初次申请1K内存，操作系统会分配1个内存页，也就是4K内存。4K是一个折中的选择，因为内存页越大，内存浪费越多，但操作系统内存调度效率高，不用频繁分配和释放内存。内存页越小，内存浪费越 少，但操作系统内存调度效率低，需要频繁分配和释放内存。