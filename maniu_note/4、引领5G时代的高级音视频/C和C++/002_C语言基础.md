# C语言基础

## 数据类型

<img src="002_C语言基础.assets/image-20220331203424822.png" alt="image-20220331203424822" style="zoom:50%;" />

## struct

```c
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    unsigned int a;// 无符号正数
    int b;
} Person;

int main() {
    Person *person = malloc(sizeof(Person));
    person->a = 44;
    person->b = 22;
    printf("a = %d\n", person->a);
    printf("b = %d\n", person->b);
    return 0;
}
```

## 宏

```c
#define David  99// 宏变量
#define ADD(x,y) ((x)+(y))// 宏函数

// 宏定义一个函数 void (int, int);
// 该函数的别名为 FUNC
typedef void FUNC(int, int);
```

## 指针

> 理解一个指针，务必清楚如下三点：
>
> - 指针自身的类型
>
> - 指针指向的类型
>
> - 指针指向的内容

### 基本使用

```c
#include <stdio.h>

int main() {
    int a = 10;
    int *p;// 定义一个地址的变量
    p = &a;// 把a的地址赋值给p

    printf("p = %d\n", *p);
    return 0;
}
```

### 指针的类型（重要）

从语法的角度看，你只要把指针声明语句里的指针名字去掉，剩下的部分就是这个指针的类型。

让我们看看如下各个指针的类型：

```
(1) int *ptr; //指针的类型是int *

(2) char *ptr; //指针的类型是char *

(3) int **ptr; //指针的类型是int **

(4) int (*ptr)[3]; //指针的类型是int(*)[3]

(5) int *(*ptr)[4]; //指针的类型是int*(*)[4]
```

###  指针所指向的类型（重要）

当你通过指针来访问指针所指向的内存区时，指针所指向的类型决定了编译器将把那片内存区里的内容当做什么来看待。

从语法上看，你只须把指针声明语句中的指针名字和名字左边的指针声明符*去掉，剩下的就是指针所指向的类型。例如：

```
(1) int *ptr; //指针所指向的类型是int

(2) char *ptr; //指针所指向的的类型是char

(3) int **ptr; //指针所指向的的类型是int*

(4) int (*ptr)[3]; //指针所指向的的类型是int()[3]

(5) int *(*ptr)[4]; //指针所指向的的类型是int *()[4]
```

在指针的算术运算中，指针所指向的类型有很大的作用，他决定步长。

“指针的类型” 和 “指针所指向的类型” 是两个概念。当你对C 越来越熟悉时，你会发现，这个是精通指针的关键点之一。

### 函数指针（重要）

```c
#include <stdio.h>

// 宏定义一个函数 void (int, int);
// 该函数的别名为 FUNC
typedef void FUNC(int, int);

void func(int a, int b) {
    printf("a = %d, b = %d\n", a, b);
}

void test(int a, int b, void (*callback)(int)) {
    int result = a + b;
    callback(result);
}

void callback(int result) {
    printf("result = %d\n", result);
}

int main() {
    /// ---- 函数也是一个指针 ----
    // 函数的 func、&func、*func 地址都相同
    func(20, 10);
    (&func)(20, 10);
    (*func)(20, 10);
    printf("func = %p\n", func);
    printf("&func = %p\n", &func);
    printf("*func = %p\n", *func);

    /// ---- 函数指针的简单使用 ----
    // 定义一个函数指针
    // p 的类型是 void (*)(int, int);
    // p 指向的内容是 void (int, int);
    void (*p)(int, int);
    // 给函数指针赋值
    p = func;
    // 调用函数指针
    p(10, 20);

    /// ---- 函数指针作为一个形参 ----
    test(30, 40, callback);

    /// ---- 使用宏来简化 函数指针的定义 ----
    FUNC *p2 = func;
    // 函数指针的取值，还是函数指针
    p2(10, 20);
    (*p2)(30, 20);

    return 0;
}
```

### 异常指针

空悬指针：指针正常初始化，曾指向过一个正常的对象，但是对象销毁了，该指针未置空，就成了悬空指针。

野指针：未初始化的指针，其指针内容为一个垃圾数。存在野指针是一个严重的错误。

### 二级指针的实现

- 实现方法一

<img src="002_C语言基础.assets/image-20220331193709024.png" alt="image-20220331193709024" style="zoom:50%;" />

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int **ptr = NULL;
    int num = 4, size = 4, i, j;

    ptr = (int **) malloc(num * sizeof(int *));
    for (i = 0; i < num; ++i) {
        *(ptr + i) = (int *) malloc(size * sizeof(int));
        for (j = 0; j < size; ++j) {
            *(*(ptr + i) + j) = (i + 1) * j;
        }
    }

    for (i = 0; i < num; ++i) {
        for (j = 0; j < size; ++j) {
            printf("(%d, %d) -> %d;\t", i, j, *(*(ptr + i) + j));
        }
        printf("\n");
    }
    return 0;
}

// 输出如下：
// (0, 0) -> 0;		(0, 1) -> 1;		(0, 2) -> 2;		(0, 3) -> 3;	
// (1, 0) -> 0;		(1, 1) -> 2;		(1, 2) -> 4;		(1, 3) -> 6;	
// (2, 0) -> 0;		(2, 1) -> 3;		(2, 2) -> 6;		(2, 3) -> 9;	
// (3, 0) -> 0;		(3, 1) -> 4;		(3, 2) -> 8;		(3, 3) -> 12;
```

- 实现方法二

<img src="002_C语言基础.assets/image-20220331202232429.png" alt="image-20220331202232429" style="zoom:50%;" />

```c
#include <stdio.h>
#include <stdlib.h>

int main() {
    int **ptr = NULL;
    int num = 4, size = 4, i, j;

    ptr = (int **) malloc(num * sizeof(int *));
    for (i = 0; i < num; ++i) {
        ptr[i] = (int *) malloc(size * sizeof(int));
        for (j = 0; j < size; ++j) {
            ptr[i][j] = (i + 1) * j;
        }
    }

    for (i = 0; i < num; ++i) {
        for (j = 0; j < size; ++j) {
            printf("(%d, %d) -> %d;\t", i, j, ptr[i][j]);
        }
        printf("\n");
    }

    return 0;
}

// 输出如下：
// (0, 0) -> 0;    (0, 1) -> 1;   (0, 2) -> 2;   (0, 3) -> 3;
// (1, 0) -> 0;    (1, 1) -> 2;   (1, 2) -> 4;   (1, 3) -> 6;
// (2, 0) -> 0;    (2, 1) -> 3;   (2, 2) -> 6;   (2, 3) -> 9;
// (3, 0) -> 0;    (3, 1) -> 4;   (3, 2) -> 8;   (3, 3) -> 12;
```

### 常量指针和指针常量（重点）

```c
// 常量指针：指向常量的指针
// 不能修改指针指向的内容，但是能修改指针的指向
// 快速记忆：指针不是常量，那么就是常量指针
int const *p;
const int *p1;

// 指针常量：指针本身是常量
// 不能修改指针的指向，但是能修改指针指向的内容
// 快速记忆：指针是常量，那么就是指针常量
int *const x;
```

## 数组

### 数组是特殊的指针

```c
#include <stdio.h>

int main() {
    int c[9] = {1, 2, 3, 4, 5, 6, 7, 8, 9};

    // 数组是一个比较特殊的指针
    printf("%p \n", c);// 首地址
    printf("%p \n", &c);// 首地址的地址，还是首地址
    printf("%p \n", &c[0]);// 第一个元素的地址，还是首地址

    printf("%d \n", *c);// 取首地址的值
    printf("%d \n", c[0]);// 取首地址的值
    printf("%d \n", *(c + 1));// 取第二个元素的值
    
    return 0;
}
```

### 指针数组

```c
#include <stdio.h>

int main() {
    int a = 10;
    int b = 20;
    int c = 30;
    int *p1 = &a;
    int *p2 = &b;
    int *p3 = &c;
    int *arr[3] = {p1, p2, p3};// 指针数组：数组里的元素是指针

    printf("%d \n", *arr[0]);// 10
    printf("%d \n", **arr);// 10

    return 0;
}
```

### 指针数组和数组指针（重点）

```c
// 指针数组：数组里面放指针
// 快速记忆：因为它是数组，所以是“指针数组”
int *arr[3];

// 数组指针：指针指向了一个数组
// 快速记忆：因为它是指针，所以是“数组指针”
int (*p)[3];
```

### 函数指针数组（重要）

```c
#include <stdio.h>

int jia(int a, int b) {
    return a + b;
}
int jian(int a, int b) {
    return a - b;
}
int cheng(int a, int b) {
    return a * b;
}
int chu(int a, int b) {
    return a / b;
}

void changeJia(int (**p)(int, int)) {
    *p = jia;
}

int main() {
    // 指针数组
    int *px[4];

    // 函数指针数组
    int (*pn[4])(int, int) = {jia, jian, cheng, chu};

    // 调用函数指针数组
    for (int i = 0; i < 4; i++) {
        printf("result = %d\n", pn[i](30, 20));
    }

    // 如果希望通过方法 改变函数指针，要传函数指针的地址
    int (*pArr)(int, int) = jian;
    printf("before changeJia = %d\n", pArr(20,10) );
    changeJia(&pArr);
    printf("after changeJia = %d\n", pArr(20,10) );

    return 0;
}
```

### 二维数组

```c
#include <stdio.h>

int main() {
    int a[] = {10, 20};																			
    int b[] = {30, 10};
    int c[] = {10};
    int *arr[3] = {a, b, c};// 二维数组

    printf("%d \n", **arr);// 10
    printf("%d \n", arr[1][1]);// 30

    return 0;
}
```

### 二维数组的使用（重点）

```c
#include <stdio.h>

int main() {
    // a[0][0]=1;		a[0][1]=2;		a[0][2]=3;		a[0][3]=4;
    // a[1][0]=5;		a[1][1]=8;		a[1][2]=7;		a[1][3]=8;
    // a[2][0]=9;		a[2][1]=10;		a[2][2]=11;		a[2][3]=12;
    int a[3][4] = {1, 2, 3, 4, 5, 8, 7, 8, 9, 10, 11, 12};

    printf("&a:%p\n", &a);// 指向整个二维数组的首地址
    printf("a:%p\n", a);// 指向第一行的首地址
    printf("*a:%p\n", *a);// 指向第一个元素的首地址

    printf("-----------------&a\n");

    printf("*&a=%d\n", sizeof(*&a));// 整个二维数组长度为48个字节
    printf("a=0x%x\n", &a);
    printf("a+1=0x%x\n ", &a + 1);// 因为步长为48字节，所以+1相当于加了48个字节

    printf("-----------------a\n");

    printf("*&a=%d\n", sizeof(*a));// 一行数组有4个元素，所以长度为16个字节
    printf("a=0x%x\n", a);
    printf("a+1=0x%x\n ", a + 1);// 因为步长为16个字节，所以+1相当于加了16个字节

    printf("-----------------*a\n");

    printf("**a=%d\n", sizeof(**a));// 第一个元素的长度为4个字节
    printf("a=%d\n", **a);// 第一个元素的值为1
    printf("a+1=%d\n ", **a + 1);// 取出首个元素再加1，所以为2

    printf("-----------------数组取值\n");

    printf("a[1][0]=%d\n ", a[1][0]);// 数组取值

    printf("-----------------指针法\n");

    // 指针法
    // int (*p)[4]: 数组指针
    // int *p[4]: 指针数组
    // p 是数组指针
    // p 指向了第一行

    // (p+1) 指向了第二行
    // *(p+1) 指向了第二行第一个元素
    // **(p+1) 第二行第一个元素的值
    int (*p)[4] = a;
    printf("a[1][0]=%d\n", **(p + 1));
    // (p + 1) 指向第二行
    // *(p + 1) 指向第二行第一个元素
    // (*(p + 1) + 1)) 指向第二行第二个元素
    // *(*(p + 1) + 1) 第二行第二个元素的值
    printf("a[1][1]=%d\n", *(*(p + 1) + 1));
    // (p + 1) 指向第二行
    // (*(p + 1)) 指向第二行第一个元素
    // *(*(p + 1)) 第二行第一个元素的值
    // *(*(p + 1)) + 1 第二行第一个元素的值+1
    printf("a[1][0]+1=%d\n", *(*(p + 1)) + 1);

    printf("-----------------打印数组\n");

    for (int i = 0; i < 3; i++) {
        for (int j = 0; j < 4; j++)
            printf("a[%d][%d]=%d;\t", i, j, *(*(p + i) + j));
        printf("\n");
    }
    
    return 0;
}
```

### 数组的遍历方式

```c
#include <stdio.h>

int main() {
    int b[3] = {10, 20, 30};

    // 下标法
    for (int i = 0; i < 3; i++)
        printf("arr[%d]=%d ", i, b[i]);

    printf("------------------------\n");

    // 地址法
    for (int i = 0; i < 3; i++)
        printf("arr[%d]=%d ", i, *(b + i));


    printf("------------------------\n");

    //指针法
    int *d = b;
    for (int i = 0; i < 3; i++)
        printf("arr[%d]=%d ", i, *(d + i));
    
    return 0;
}
```

## 字符串

### 字符串的大小和长度

```c
#include <stdio.h>
#include "string.h"

int main() {

    char str[] = {'h', 'e', 'l', 'l', 'o'};// 栈区
    char str1[] = "hello";// 栈区
    char *str2 = "hello";// 常量区

    printf("sizeof(str)=%d\n", sizeof(str));// 5个字节大小
    printf("sizeof(str1)=%d\n", sizeof(str1));// 6个字节大小，因为尾部会自动加一个字符'\0'
    printf("sizeof(str2)=%d\n", sizeof(str2));// 8个字节大小，因为指针的大小都是8个字节

    printf("strlen(str)=%d\n", strlen(str));// 5个字符长度
    printf("strlen(str1)=%d\n", strlen(str1));// 5个字符长度
    printf("strlen(str2)=%d\n", strlen(str2));// 5个字符长度

    return 0;
}
```

### 字符串的拷贝

```c
#include <stdio.h>
#include "string.h"

int main() {
    char s1[] = "123456789";// 栈区

    printf("s1 = %s\n", s1);// 123456789
    printf("strlen(s1) = %d\n", strlen(s1));// 9
    printf("sizeof(s1) = %d\n", sizeof(s1));// 10

    strcpy(s1, "david");// 把 “参数2” 的值拷贝给 “参数1”
    printf("s1 = %s\n", s1);// david
    printf("strlen(s1) = %d\n", strlen(s1));// 5
    printf("sizeof(s1) = %d\n", sizeof(s1));// 10
    printf("s1[5] = %d\n", s1[5]);// 0
}

// 1, 2, 3, 4, 5, 6,	 	7, 8, 9, '\0'
// d, a, v, i, d, '\0',	7, 8, 9, '\0'
```

### 常量字符串不能被修改

```c
// 在栈区定义一个指针变量 "str2"
// 在常量区有一个值为 "hello"
// "str2" 指向 "hello"
char *str2 = "hello";

// 因为 "hello" 在常量区，所以不能被修改
//*str2 = "david";

// 虽然 "hello" 在常量区，不能被修改
// 但是指针变量 "str2" 的指向可以被修改
str2 = "kitty";
```

### 拼接字符串

```c
void mystrcat(char *s1, char *s2) {
    // -----------------------------------
    // 拼接两个字符串：将 s2 拼接到 s1 的尾部
    // -----------------------------------

    // *s1 不为空，指针就会一直往后移动，最后移动到 s1 的尾部
    while (*s1) s1++;
    // 要把 s2 拼接到 s1 的尾部
    // *s1 = *s2
    // *s1+1 = *s2+1
    // ......
    // 直到 s1 指向 s2 的末尾，也就是 *s1 为空时跳出循环
    while (*s1++ = *s2++);
}

int main() {
    char s1[] = "abc";
    char s2[] = "123";

    // 拼接两个字符串：将 s2 拼接到 s1 的尾部
    mystrcat(s1, s2);

    printf("s1 = %s\n", s1);// abc123
    printf("s2 = %s\n", s2);// 123
    printf("str[6] = %d\n", s1[6]);// 0
  
    // 如下方式是错误的，原因分析内存图便知
    char *s3 = "abc";
    char *s4 = "123";
    //mystrcat(s3, s4);
    //printf("s3 = %s\n", s3);

    return 0;
}
```

### 字符串数组（重点）

```c
#include <stdio.h>
#include "string.h"

int main() {
    // ----------------------------------------------
    // 字符串数组（指针常量）
    // ----------------------------------------------

    // 字符串数组是 "二维数组"
    // 指针是常量，但是指针指向的元素不是常量
    // 因此 arr 是 "指针常量"
    char arr[4][6] = {"abc", "efg", "hij", "klm"};

    // 因为指针指向的元素不是常量，所以能被修改
    // 将 "abc" 修改为 "aaaaa"
    strcpy(arr[0], "aaaaa");
    printf("arr[0] = %s\n", arr[0]);

    // ----------------------------------------------
    // 字符串数组（常量指针）
    // ----------------------------------------------

    // 因为 arr1 是个数组，数组中的元素是指针
    // 所以 arr1 是 "数组指针"
    //
    // 因为指针(arr1)不是常量，指针(arr1)指向的内容是常量
    // 所以 arr1 是 "常量指针"
    char *arr1[4] = {"abc", "efg", "hij", "klm"};

    // 因为 "abc" 是常量，所以不能被修改
    //strcpy(arr1[0], "aaaaa");
  
    return 0;
}
```

## 内存分配

C语言的标准内存分配函数：malloc，calloc，realloc，free等。

- malloc(size): 在内存的动态存储区中分配一块长度为size字节的连续区域，返回该区域的首地址。
  - malloc只分配空间不初始化，也就是依然保留着这段内存里的数据。

- calloc(n, size)：在内存的动态存储区中分配n块长度为size字节的连续区域，返回首地址。
  - calloc分配的空间全部初始化为0。

- realloc(*ptr, size)：将ptr内存大小增大到size。

- free(void \*ptr)：释放ptr所指向的一块内存空间。

## 内存管理机制

​		**代码区：**程序被操作系统加载到内存的时候，所有的可执行代码(程序代码指令、常量字符串等)都加载到 代码区，这块内存在程序运行期间是不变的。代码区是平行的，里面装的就是一堆指令，在程序运行期 间是不能改变的。函数也是代码的一部分，故函数都被放在代码区，包括main函数。

​		**静态区：**静态区存放程序中所有的全局变量和静态变量。

​		**栈区：**栈(stack)是一种先进后出的内存结构，所有的自动变量、函数形参都存储在栈中，这个动作由编译器自动完成，我们写程序时不需要考虑。栈区在程序运行期间是可以随时修改的。当一个自动变量超出其作用域时，自动从栈中弹出。

每个线程都有自己专属的栈。栈的最大尺寸固定，超出则引起栈溢出。变量离开作用域后栈上的内存会自动释放。

​		**堆区：**堆和栈一样，也是一种在程序运行过程中可以随时修改的内存区域，但没有栈那样先进后出的顺序。更重要的是堆是一个大容器，它的容量要远远大于栈，这可以解决内存溢出困难。一般比较复杂的数据类型都是放在堆中。但是在C语言中，堆内存空间的申请和释放需要手动通过代码来完成。

malloc函数用来在堆中分配指定大小的内存，单位为字节(Byte)，函数返回void *指针。free负责在 堆中释放malloc分配的内存。

​		**什么时候用堆什么时候用栈呢？**一般遵循以下三个原则：

- 如果明确知道数据占用多少内存，那么数据量较小时用栈，较大时用堆。
- 如果不知道数据量大小(可能需要占用较大内存)，最好用堆(因为这样保险些)。
- 如果需要动态创建数组，则用堆。

​		操作系统在管理内存时，最小单位不是字节，而是**内存页**(32位操作系统的内存页一般是4K)。比如，初次申请1K内存，操作系统会分配1个内存页，也就是4K内存。4K是一个折中的选择，因为内存页越大，内存浪费越多，但操作系统内存调度效率高，不用频繁分配和释放内存。内存页越小，内存浪费越 少，但操作系统内存调度效率低，需要频繁分配和释放内存。