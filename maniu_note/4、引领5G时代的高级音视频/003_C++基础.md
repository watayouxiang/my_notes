# C++基础

> 从语法上看，C语言是 C++ 的一部分，学了C语言就相当于学了 C++ 的一半。

## 类的定义及调用

```c++
#include <iostream>

class Student {
public:
    char *name;
    int age;
    float score;

    void say() {
        printf("name %s age %d score %f\n", name, age, score);
    }
};

int main() {
    class Student stu{};
    stu.name = "xiaoping";
    stu.age = 15;
    stu.score = 92.5f;
    stu.say();
    return 0;
}
```

## 命名空间

```c++
namespace namespaceA {
    namespace namespaceB {
        struct Teacher {
            int age = 30;
        };
    }
    int a = 10;
}

int main() {
    int a = namespaceA::a;

    using namespace namespaceA;
    int c = a;

    using namespace namespaceA::namespaceB;
    Teacher teacher;

    return 0;
}
```

## cin和cout

```c++
#include <iostream>

using namespace std;

int main() {
    // 输出流 cout <<
    // endl: 作用相当于 flush()，并会换行
    cout << "Hello, World!" << endl;

    cout << "hello, ";
    cout << "World!";
    cout << endl;

    cout << "hello, "
         << "World!"
         << endl;

    // 输入流 cin >>
    // 定义三个变量，并从输入流中接收。
    // 输入一个数值后，回车，接收下一个数值
    //
    // 控制台打印如下：
    // h
    // 67
    // 4724723
    // a = h
    // b = 67
    // c = 4.72472e+06
    char a;
    int b;
    float c;
    cin >> a >> b >> c;
    cout << "a = " << a << endl
         << "b = " << b << endl
         << "c = " << c << endl;

    return 0;
}
```

## 引用

### 引用是什么

```c++
#include <iostream>

int main() {
    // 引用：就是某一变量的一个别名，对引用的操作与对变量直接操作完全一样。
    // 引用不会开辟内存空间，所以相对于指针更为省空间
    // & 在等于号前表示 引用
    int a = 10;
    int &b = a;
    b = 100;

    printf("a: %d \n", a);
    printf("b: %d \n", b);
    printf("a: %p \n", &a);
    printf("b: %p \n", &b);

    // 常量引用不能被修改
    int const &c = a;
    // c = b;

    return 0;
}
```

### 引用实现两数交换

```c++
#include <iostream>

using namespace std;

// 引用实现两数交换
void swap(int &p1, int &p2) {
    int p = p1;
    p1 = p2;
    p2 = p;
}

int main() {
    int a = 20, b = 40;
    cout << "a = " << a << ", b = " << b << endl;
    swap(a, b);
    cout << "a = " << a << ", b = " << b << endl;

    return 0;
}
```

### 引用作为返回值

```c++
#include <iostream>

using namespace std;

float temp;

float &fn2(float r) {
    temp = (float) (r * r * 3.14);
    return temp;
}

float &fn1(float r) {
    // 1) 如果函数返回是&，内部不可以直接 return (float)(r*r*3.14)
    //    因为返回值为引用类型，而这样的返回是 float 类型
    // 2) 可以这样返回：float &b = a; return b;
    // 3) 也可以直接返回：return a; (因为编译器会自动把该值转换成引用)
    // 4) 变量 a 必须为全局变量，否则一旦走出该函数的作用域，变量 a 便不存在，同样 a 的引用也不存在
    float a = (float) (r * r * 3.14);
    return a;
}

int main() {
    // 错误：虽然有值，但值是错误的
    float &f1 = fn1(100.0);
    cout << "错误举例：" << f1 << endl;// 错误举例：2.1577e+20

    // 正确
     float &f2 = fn2(100.0);
    cout << "正确举例：" << f2 << endl;// 正确举例：31400

    // 正确
    float f3 = fn2(100.0);
    cout << "正确举例：" << f3 << endl;// 正确举例：31400
}
```

### 引用作为返回值2

```c++
#include <iostream>

using namespace std;

int data[10];
int error = -1;

int &put(int n) {
    if (n >= 0 && n <= 9) {
        return data[n];
        // 相当于如下：
        // int &d = data[n];
        // return d;
    } else {
        cout << "subscript error";
        return error;
    }
}

int main() {
    put(0) = 10;// 等价于 data[0] = 10
    put(9) = 20;// 等价于 data[9] = 20;

    cout << "data[0] = " << data[0] << endl;// data[0] = 10
    cout << "data[9] = " << data[9] << endl;// data[9] = 20
}
```

## 函数

### inline内联函数

```c++
#include <iostream>

using namespace std;
#define ADD(x, y) (x+y)// 宏定义

// 內联函数：在编译时将函数体嵌入在每一个调用处
//
// 内联函数和宏定义的区别：宏是由预处理器对宏进行替代，而内联函数是通过编译器控制来实现的
//
// 內联函数使用的注意事项：
// 1）不能存在任何形式的循环语句
// 2）不能存在过多的条件判断语句
// 3）函数体不能过于庞大
// 4）不能对函数进行取址操作
// 总结：內联函数内不要有 for循环、switch语句、递归。否则內联函数会被当作普通函数处理
inline int Add(int x, int y) {
    return x + y;
}

int main() {
    int result = Add(10, 20);
    cout << "result = " << result << endl;
    return 0;
}
```

### 函数的默认参数

```c++
#include <iostream>

using namespace std;

// 函数的默认参数
//
// int x 实参；int y = 10 默认参数；int = 10 占位参数
// 实参在前，默认参数在后。
//
// 占位参数的作用是：
// 1）兼容C语言程序中可能出现的不规范写法
// 2）为以后程序的扩展留下线索
void test(int x, int y = 10, int = 10) {
    cout << "x: " << x << ", y: " << y << endl;
}

int main() {
    test(10);
    test(10, 20);
    test(10, 20, 30);
    return 0;
}
```

### 函数的重载

```c++
// ----------------------------------------------
// 重载函数
// ----------------------------------------------

void test(int a) {}

// 与 void test(int a) {} 是重载
// 与 void test(int a, int b = 20) {} 不是重载
// void test(int a, int b) {}

// 默认参数
void test(int a, int b = 20) {}

// 指针
void test(int *a) {}

// 常量指针：指针指向常量
void test(const int *a) {}

// 指针常量 不是重载：(int *a) 和 (int *const a) 存在二义性
// void test(int *const a) {}

// 引用 不是重载：(int a) 和 (int &a) 存在二义性
// void test(int &a) {}

// 常量引用 不是重载：(int a) 和 (const int &a) 存在二义性
// void test(const int &a) {}

// ----------------------------------------------
// typedef
// ----------------------------------------------

typedef void (*myFunc)(int a);
typedef void (*myFunc2)(int a, int b);

// ----------------------------------------------
// main函数
// ----------------------------------------------

int main() {
    // void test(int a) {}
    myFunc func1 = test;
    func1(10);

    // void test(int a, int b = 20) {}
    myFunc2 func2 = test;
    func2(10, 20);

    // void test(int *a) {}
    int a = 10;
    int *p = &a;
    test(p);

    // void test(const int *a) {}
    int a2 = 10;
    const int *p2 = &a2;
    test(p2);

    return 0;
}
```

### 常函数

```c++
class Person {
public:
    int a = 10;

    // 1.1) 用const修饰的声明数据成员称为常数据成员
    const int b = 20;

    // 1.2) 被const修饰的函数，为常函数
    void showPerson() const {}
};

int main() {
    // 1.3) 用const修饰的对象称为常对象
    const Person person;

    return 0;
}
```

## 防止头文件重复引用

<img src="003_C++基础.assets/image-20220408170049037.png" alt="image-20220408170049037" style="zoom:50%;" />

**Test.h**

```c++
#ifndef LS8_TEST_H
#define LS8_TEST_H

class Test {

private:
    int b;
protected:
    int c;
public:
    int age;

    int getAge();

    void setAge(int age);

};

#endif
```

**Test.cpp**

```c++
#include "include/Test.h"

int Test::getAge() {
    return age;
}

void Test::setAge(int age) {
    this->age = age;
}
```

**main.cpp**

```c++
#include <iostream>

using namespace std;

#include "include/Test.h"

int main() {
    Test *test = new Test;
    test->setAge(18);
    cout << "age: " << test->getAge() << endl;
}
```

**CMakeLists.txt**

```
cmake_minimum_required(VERSION 3.16.5)
project(LS8)

set(CMAKE_CXX_STANDARD 14)

add_executable(LS8 Test.cpp include/Test.h main.cpp)
```

## 对象

### 构造函数和析构函数

```c++
#include <iostream>

using namespace std;

class Person {
public:
    // 构造函数：初始化对象，可重载
    Person() {
        cout << "Person()" << endl;
    }

    Person(int a) {
        cout << "Person(int a)" << endl;
    }

    Person(int a, int b) {
        cout << "Person(int a, int b)" << endl;
    }

    // 析构函数：销毁对象，不可重载
    ~Person() {
        cout << "delete person" << endl;
    }
};

int main() {
    // 如下创建对象方式：都是在栈中创建person对象
    // new关键字创建对象方式：相当于malloc，是在堆中创建person对象
  
    // 最简单的
    Person person;
    // 显示法
    Person person1 = Person(10);
    Person person2 = Person(10, 20);
    // 隐式法
    Person person3 = 10;
    // 括号法
    Person person4(10);

    return 0;
}
```

### 构造函数2

```c++
#include <iostream>

using namespace std;

class Person {
public:
    int a;
    int b;
    int c;

//    Person(int a, int b, int c) {
//        this->a = a;
//        this->b = b;
//        this->c = c;
//    }

    // 等同于上面述注释
    Person(int a, int b, int c) : a(a), b(b), c(c) {}

    Person() : a(10), b(20), c(30) {}
};

int main() {
    Person p;
    cout << "a: " << p.a << ", b: " << p.b << ", c: " << p.c << endl;// a: 10, b: 20, c: 30

    Person p1(1, 2, 3);
    cout << "a: " << p1.a << ", b: " << p1.b << ", c: " << p1.c << endl;// a: 1, b: 2, c: 3
}
```

### 拷贝函数

```c++
#include <iostream>

using namespace std;

class Person {
public:
    int age = 0;
    char *name;

    Person(int age, char *name) {
        cout << "Person(int a)" << endl;
        this->age = age;
        // 堆区开辟空间: 因为 name 是以 /0 结束的，所以这里开辟的空间需要 +1
        this->name = (char *) malloc(strlen(name) + 1);
        strcpy(this->name, name);
    }

    // 拷贝函数
    // 默认拷贝函数是：浅拷贝
    // 如何实现深拷贝：重写拷贝函数，自行实现深拷贝
    Person(const Person &person) {
        cout << "Person(const Person &person)" << endl;

        // 1）因为 person 是常量引用，因此 person 只能够读，不能写。
        // person.a = 10;

        // 2）默认的拷贝函数会自动补全如下代码。所以重写拷贝函数时，也要补全如下代码
        this->age = person.age;

        // 3）默认的拷贝函数是浅拷贝，没办法拷贝name，所以这里需要自行实现深拷贝
        this->name = (char *) malloc(strlen(person.name) + 1);
        strcpy(this->name, person.name);
    }

    ~Person() {
        cout << "delete person, age = " << age << ", name = " << name << endl;
        // 释放堆中的对象
        if (this->name != NULL) {
            free(name);
            name = NULL;
        }
    }
};

int main() {
    Person person1 = Person(18, "xiaowang");

    // person2先销毁，person1再销毁。因为栈是先进后出结构
    Person person2(person1);

    return 0;
}

// 控制台打印如下：
// Person(int a)
// Person(const Person &person)
// delete person, age = 18, name = xiaowang
// delete person, age = 18, name = xiaowang
```

### 单例对象

```c++
#include <iostream>

using namespace std;

class Instance {
public:
    static Instance *getInstance() {
        return instance;
    }

private:
    static Instance *instance;

    // 私有化 "无参构造函数"
    Instance() {};

    // 私有化 "拷贝函数"
    // 因为通过 "拷贝函数" 创建的对象并非单例
    Instance(const Instance &) {};

};

Instance *Instance::instance = new Instance;

int main() {
    Instance *c1 = Instance::getInstance();
    Instance *c2 = Instance::getInstance();

    if (c1 == c2) {
        cout << "c1 = c2" << endl;
    } else {
        cout << "c1 != c2" << endl;
    }

    return 0;
}
```

### 计算对象的所占的字节数

```c++
#include <iostream>

using namespace std;

// 空对象占用1个字节
class EmptyPerson {
};

// 最大元素的整数倍，所以占8字节
class Person {
private:
    int a = 10;// 4字节
    char b = 'b';// 1字节
    static int e;// 存放静态区，不做统计

public:
    void test() {// 存放代码区，不做统计
    }
};

// 最大元素的整数倍，所以占16字节
struct Person1 {
    double a = 10;// 8字节
    char b = 'b';// 1字节
};

int main() {
    EmptyPerson emptyPerson;
    cout << "sizeof(emptyPerson) = " << sizeof(emptyPerson) << endl;

    Person person;
    cout << "sizeof(person) = " << sizeof(person) << endl;

    Person1 person1;
    cout << "sizeof(person1) =  " << sizeof(person1) << endl;

    return 0;
}
```

### explicit关键字

```c++
using namespace std;

class Person {
public:
    explicit Person(int a) {}
};

int main() {
    // --------------------------------------------
    // 被 explicit 修饰过的构造函数，不支持隐式法调用
    // 
    // explicit中文含义：明确的；清晰的；
    // --------------------------------------------

    // 隐式法（不支持）
    // Person person = 10;

    // 显示法（支持）
    Person person1(10);

    return 0;
}
```

### new关键字

```c++
#include <iostream>

using namespace std;

class Person {
public:
    Person() {
        cout << "Person()" << endl;
    }

    ~Person() {
        cout << "delete Person" << endl;
    }
};

int main() {
    // 1）new 关键字创建对象
    // 堆区开辟内存，相当于malloc
    Person *person = new Person;
    // 释放堆中的person对象，相当于free
    delete person;

    // 2）如下方式是 无法释放p对象的
    // void *p = new Person;
    // delete p;

    // 3）数组对象pArray的创建与释放
    Person *pArray = new Person[3];
    delete[] pArray;

    return 0;
}
```

### mutable关键字

```c++
class Person {
public:
    int a = 10;
  
    mutable int c = 100;
};

int main() {
    // 用const修饰的对象称为常对象
    const Person person;

    // 常对象的数据成员不能被修改
    // person.a = 2;

    // 若想修改，可以添加 mutable 关键字
    person.c = 100;

    return 0;
}
```

## C++实现ArrayList

### ArrayList.h

```c++
#ifndef LS10_ARRAYLIST_H
#define LS10_ARRAYLIST_H


class ArrayList {
public:
    // 构造函数
    ArrayList();

    // 构造函数
    // explicit修饰后，不能通过隐式调用
    explicit ArrayList(int capacity);

    // 拷贝函数
    ArrayList(const ArrayList &arrayList);

    // 析构函数
    ~ArrayList();

    // 数组末尾添加一个元素
    void add(int val);

    // 在指定位置，插入一个元素
    void add(int val, int size);

    // 获取指定位置的元素
    int get(int pos);

    // 移除指定位置的元素
    void remove(int index);

    // 获取数组长度
    int getLength();

    // 判断数组是否为空
    bool isEmpty();

    // 数组扩容
    void resize();

    void toString();

private:
    // 数组长度
    int size;

    // 实际大小
    int actulSize;

    // 数组
    int *arr;
};


#endif
```

### ArrayList.cpp

```c++
#include "ArrayList.h"
#include "iostream"

using namespace std;

// 构造函数
ArrayList::ArrayList() {
    this->size = 16;
    this->actulSize = 0;
    this->arr = new int[this->size];
}

// 构造函数
ArrayList::ArrayList(int capacity) {
    this->actulSize = 0;
    this->size = capacity;
    // new malloc 创建的对象存放在堆，都需要手动释放
    // new delete / malloc free
    this->arr = new int[this->size];
}

// 析构函数
ArrayList::~ArrayList() {
    if (this->arr != NULL) {
        delete[] this->arr;
        this->arr = NULL;
    }
}

// 拷贝构造函数
ArrayList::ArrayList(const ArrayList &arr) {
    this->actulSize = arr.actulSize;
    this->size = arr.size;
    // 实现数组深拷贝
    this->arr = new int[arr.size];
    for (int i = 0; i < size; ++i) {
        this->arr[i] = arr.arr[i];
    }
}

void ArrayList::add(int val) {
    add(val, actulSize);
}

void ArrayList::add(int val, int index) {
    if (index < 0 || index > size) {
        return;
    }
    if (this->actulSize >= size) {
        resize();
    }
    this->arr[index] = val;
    actulSize++;
}

void ArrayList::resize() {
    int neLength = size * 2;
    int *p = new int[neLength];
    for (int i = 0; i < size; ++i) {
        *(p + i) = arr[i];
    }
    delete[] this->arr;// 释放原来的数据
    this->arr = p;
    this->size = neLength;
}

int ArrayList::get(int index) {
    if (index < 0 || index > size) {
        return -1;
    }
    return this->arr[index];
}

void ArrayList::remove(int index) {
    if (index < 0 || index > size) {
        return;
    }
    for (int i = index; i < size - 1; ++i) {
        arr[i] = arr[i + 1];
    }
    actulSize--;
}

int ArrayList::getLength() {
    return actulSize;
}

bool ArrayList::isEmpty() {
    return actulSize == 0;
}

void ArrayList::toString() {
    cout << "[ ";
    for (int i = 0; i < actulSize; i++) {
        cout << arr[i];
        if (i < actulSize - 1) {
            cout << ", ";
        }
    }
    cout << " ]" << endl;
}
```

### main.cpp

```c++
#include <iostream>
#include "ArrayList.h"

using namespace std;

int main() {
    // ArrayList *arrayList = new ArrayList();// 堆中创建对象

    ArrayList arrayList = ArrayList(2);// 栈中创建对象
    arrayList.add(1);
    arrayList.add(2);
    arrayList.add(3);
    arrayList.add(4);
    arrayList.add(5);
    arrayList.toString();
    arrayList.remove(3);
    arrayList.toString();

    cout << "arrayList.get(0) = " << arrayList.get(0) << endl;
    cout << "arrayList.getLength() = " << arrayList.getLength() << endl;
    cout << "arrayList.isEmpty() = " << arrayList.isEmpty() << endl;

    return 0;
}
```