# 线程安全性分析

## 并发编程问题的源头

原子性：线程切花引起

可见性：cpu高速缓存引起

有序性：编译器重排序、处理器冲排序

<img src="012_JUC之线程的安全分析.assets/image-20220315105716580.png" alt="image-20220315105716580" style="zoom:50%;" />

1. cpu增加了高速缓存，均衡和内存的速度差异
2. 操作系统增加进程、线程以及分时复用cpu，均衡cpu与i/o设备的速度差异
3. 编译程序优化指令的执行顺序，使得能够更合理的利用缓存

## java内存模型（JMM）

<img src="012_JUC之线程的安全分析.assets/image-20220315110333101.png" alt="image-20220315110333101" style="zoom:50%;" />

## volatile关键字分析

<img src="012_JUC之线程的安全分析.assets/image-20220315110531264.png" alt="image-20220315110531264" style="zoom:80%;" />

## final域

![image-20220315111239140](012_JUC之线程的安全分析.assets/image-20220315111239140.png)

## Happens-before

![image-20220315111409717](012_JUC之线程的安全分析.assets/image-20220315111409717.png)

## 原子操作

<img src="012_JUC之线程的安全分析.assets/image-20220315111506011.png" alt="image-20220315111506011" style="zoom:60%;" />



## ThreadLocal的使用原理

![image-20220315111553013](012_JUC之线程的安全分析.assets/image-20220315111553013.png)

## 线程安全-锁

### JVM普通对象头32位Mark word解析

![image-20220315111553013](012_JUC之线程的安全分析.assets/JVM普通对象头32位Mark word解析.png)

### 轻量级锁内存应用过程

![image-20220315111553013](012_JUC之线程的安全分析.assets/轻量级锁内存应用过程.png)

### 锁膨胀过程

![image-20220315111553013](012_JUC之线程的安全分析.assets/锁膨胀.png)

### synchronize与Monitor

![image-20220315111553013](012_JUC之线程的安全分析.assets/synchronize与Monitor.png)

## 线程安全-CAS

![image-20220315115739555](012_JUC之线程的安全分析.assets/image-20220315115739555.png)