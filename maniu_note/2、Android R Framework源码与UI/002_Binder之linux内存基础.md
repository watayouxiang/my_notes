# Binder之linux内存基础

Linux已有进程通信（管道、共享内存、Socket、File）都不能满足安卓系统，所以才要会有Binder机制。

## Linux相关知识点

### Linux内存基础

- 用户空间：用户空间是用户所能访问的空间，App进程跑在用户空间中。
- 内核空间：内核空间是 “系统代码”、“驱动代码”、“内核代码”、“内核进程” 所在的空间。
- MMU
  - Memory Management Unit，内存管理单元，MMU负责的是虚拟地址和物理地址的转换。
  - 页表：虚拟地址和物理地址的映射表
  - 页的概念：为了CPU的高效执行以及方便的内存管理，每次需要拿一页的代码。这个页，指的是一段连续的存储空间（常见的是4K），也叫做块。
- 程序的局部性原则：进程的代码只有局部在物理内存中运行。这是因为程序具有局部性原则，所以在某一小段时间段内，只有很少一部分代码会被CPU执行。
- 磁盘高速缓存区：磁盘高速缓存区在磁盘中，一般大小在8M～16M，磁盘高速缓存区的速度和内存条相当。
- Binder
  - Binder的优势：减少物理内存的拷贝次数
  - Binder一次最多能拷贝多大数据：1M-8K，ProcessState.cpp中定义了BINDER_VM_SIZE为 (1M-8K)
  - Binder的调用：App1 用copy_from_user() 将数据从用户空间拷贝到内核空间。内核空间内有 “内核缓存区” 和 “数据接收缓存区”，它们间存在一对一映射关系，而 “数据接收缓存区” 又与 App2 的用户空间存在映射关系，因此 App2 可以直接拿到 “数据接收缓存区” 中的数据（也就是 App1 的数据）。
  - Binder少拷贝一次发生在客户端还是服务端：服务端
- mmap函数
  - 1、物理内存中开辟4096字节内存
  - 2、将物理内存与磁盘进行对应
  - 3、MMU将mmap开辟的物理地址转换成虚拟地址

### 普通linux进程通信的方式

<img src="002_Binder之linux内存基础.assets/image-20220322162605135.png" alt="image-20220322162605135" style="zoom:50%;" />

进程间，用户空间的数据不可共享，所以用户空间相当于私有空间

进程间，内核空间的数据可共享，所以内核空间 相当于公共空间

进程间如果需要做到通信，需要通过共享空间对数据转换。转换过程需要调用系统的api，这个过程称为**系统调用**

### linux为什么要分内核空间和用户空间

<img src="002_Binder之linux内存基础.assets/image-20220322165954713.png" alt="image-20220322165954713" style="zoom:50%;" />

linux系统在高优先级模式中运行系统**内核代码**以及与**硬件密切**相关的代码。**低优先级**运行**应用程序**与硬件无关部分。

这样做的好处有：

- 应用程序崩溃**不会造成内核崩溃**，拿windows举例来说，**QQ崩溃掉不会造成程序死机**。
- 每个应用程序或者进程都会有自己特定的地址、私有数据空间，**程序之间一般不会相互影响**。例如QQ崩溃不会造成微信的崩溃。空间的隔离极大地提高了系统运行的稳定性。

### 什么是MMU

- MMU (Memory Management Unit) 内存管理单元：主要用来管理 虚拟存储器、物理存储器 的控制线路，同时也负责虚拟地址映射为物理地址，以及提供硬件机制的内存访问授权、多任务多进程操作系统。
- 虚拟存储器的基本思想是：**程序、数据、堆栈的总大小可以超过内存空间的大小，**操作系统将当前运行的部分保存在内存中，未使用的部分保存在磁盘中。
  - 比如一个**16MB的程序**和一个**内存只有4MB**的机器，操作系统通过选择可以决定哪部分4MB的程序内容保存在内存中，并在需要时，在内存与磁盘中交换程序代码，这样16MB的代码就可以运行在4MB的机器中了。

### 地址范围、虚拟地址与物理地址

- **地址范围**：指处理器能够产生的地址集合，如一个32bit的处理器，其能产生的地址集合是**0x0000 0000 ~ 0xffff ffff** (4G)，这个地址范围也称为**虚拟地址空间**，其中对应的地址为**虚拟地址**。
- **虚拟地址与物理地址**：与虚拟地址空间和虚拟地址相对应的是物理地址空间和物理地址；物理地址空间只是虚拟地址空间的一个**子集**。如一台内存为256MB的32bit主机，其虚拟地址空间是0 ~ 0xffffffff(4GB)，**物理地址空间**范围是0 ~ 0x0fff ffff(256M)。

### 分页机制 (页、页帧、页表)

如果处理器没有MMU，或者有MMU但没有启用，CPU执行单元发出的内存地址将直接传到芯片引脚上，被内存芯片（以下称为物理内存，以便与虚拟内存区分）接收，这称为物理地址（**Physical Address**，以下简称**PA**），如下图所示：

<img src="002_Binder之linux内存基础.assets/image-20220322173533525.png" alt="image-20220322173533525" style="zoom:50%;" />

如果处理器启用了MMU，CPU执行单元发出的内存地址将被MMU截获，从CPU到MMU的地址称为虚拟，而MMU将这个地址翻译成另一个地址发到CPU芯片的外部地址引脚上，也就是将VA映射成PA，如下图：

<img src="002_Binder之linux内存基础.assets/image-20220322173616856.png" alt="image-20220322173616856" style="zoom:50%;" />

- linux使用MMU的机器都采用**分页机制**。虚拟地址空间以**页**为单位进行划分，而相应的物理地址空间也被划分，其使用的单位称为**页帧**，页帧和页必须保持相同，因为**内存与外部存储器之间的传输是以页为单位进行传输的**。

- 虚拟内存的哪个**页**面映射到物理内存的哪个**页帧**是通过**页表（Page Table）**来描述的，页表保存在**物理内存中**，**MMU会查找页表来确定一个VA应该映射到什么PA。**

### 交换区

实际上就是一块磁盘空间（硬盘空间）。虚拟内存与物理内存映射的时候，是将虚拟内存的代码放到交换区中，以后在CPU想要执行相关的指令或者数据时，如果内存中没有，先去交换区将需要的指令与数据映射到物理内存，然后CPU再执行。

虚拟内存与交换取的这种概念，实现了大内存需求量的（多个）进程，能够（同时）运行在较小的物理内存中。如下图所示：

<img src="002_Binder之linux内存基础.assets/image-20220322202955680.png" alt="image-20220322202955680" style="zoom:50%;" />

上图中，说的是进程的局部代码在物理内存中运行。是因为程序具有局部性原则，所以在某一段很小的时间段内，只有很少一部分代码会被CPU执行。

### 虚拟页、物理页

- 从交换区获取程序的代码，将它拿到物理内存执行。**那么一次拿多少代码过来呢？这是一个问题！**

- 为了CPU的高效执行以及方便的内存管理，每次需要拿一个**页的代码**。这个页，指的是一段连续的存储空间（常见的是4Kb），也叫作块。

- 假设页的大小为P。在虚拟内存中，叫做**虚拟页（VP）**。从虚拟内存拿了一个页的代码要放到物理内存，那么自然物理内存也得有一个刚好一般大小的页才能存放虚拟页的代码。物理内存中的页叫做**物理页（PP）**
- 在任何时刻，虚拟页都是以下三种状态中的一种：
  - 未分配的：VM系统还未分配的页（或者未创建）。未分配的页还没有任何数据与代码与他们相关联，因此也就不占用任何磁盘。
  - 缓存的： 当前已缓存在物理内存中的已分配页
  - 未缓存的：未缓存在物理内存中的已分配页

### 页命中

<img src="002_Binder之linux内存基础.assets/image-20220322204244143.png" alt="image-20220322204244143" style="zoom:50%;" />

当CPU得到一个地址vaddr想要访问它（这个addr就是上面想要访问的某一个字节的地址）：

- 通过MMU，将虚拟地址addr作为索引定位到页表的PTE条目中的PTE2（这里假设是PTE2）
- 从内存中去读到PTE2的有效位为1，说明该虚拟页面已经被缓存了，所以CPU使用该PTE2条目中的物理内存地址（这个物理内存地址是PP1中的起始地址）构造出vaddr的物理地址paddr（这个地址是PP1页面起始地址或后面的某一个地址）。
- 然后CPU就会去paddr这个物理内存地址去取数据。这种情况，就是也命中。

## Binder相关知识点

### Binder四层源码

>  Binder源码有四层：driver、framework、jni、native
>

![image-20220322151824804](002_Binder之linux内存基础.assets/Binder的四层结构.png)

### [Binder4层源码链接](002_Binder之linux内存基础.assets/Binder4层源码)

### mmap函数和binder驱动

- 所有的应用都与内核空间的内存发生频繁的调用，在Binder中传递数据本质上是通过文件读取来实现的。

- Linux是文件操作系统，都是基于文件展开的，File也能实现进程通信。

- Binder机制中，在内存与文件中设计了一层映射关系。映射指的是内存与文件的映射，映射是通过mmap函数，而mmap函数需要依赖一个文件，这个文件叫做 “binder”。该文件没有后缀名，他实际上就是一个文件，但是人们习惯性的把它称为**binder驱动**。
- 服务端Service 也通过mmap函数监听文件的变化

<img src="002_Binder之linux内存基础.assets/image-20220322163443479.png" alt="image-20220322163443479" style="zoom:50%;" />

### mmap是如何实现一次拷贝的

<img src="002_Binder之linux内存基础.assets/image-20220322163928428.png" alt="image-20220322163928428" style="zoom:50%;" />

- 基于 mmap 又是如何实现一次拷贝的？

  - Client 与 Server 处于不同进程有着不同的虚拟地址规则，所以无法直接通信。而一个页框可以映射给多个页，那么就可以将一块物理内存分别与 Client 和 Server 的虚拟内存块进行映射。

  - 如图， Client 就只需 copy_from_user 进行一次数据拷贝，Server 进程就能读取到数据了。另外映射的虚拟内存块大小将近 1M (1M-8K)，所以 IPC 通信传输的数据量也被限制为此值。

- 怎么理解页框和页？
  - 页框是指一块实际的物理内存，页是指程序的一块内存数据单元。内存数据一定是存储在实际的物理内存上，即页必然对应于一个页框，页数据实际是存储在页框上的。
  - 页框和页一样大，都是内核对内存的分块单位。一个页框可以映射给多个页，也就是说一块实际的物理存储空间可以映射给多个进程的多个虚拟内存空间，这也是 mmap 机制依赖的基础规则。

### Binder的整体架构

<img src="002_Binder之linux内存基础.assets/image-20220322164802531.png" alt="image-20220322164802531" style="zoom:40%;" />

- Client 通过 ServiceManager 或 AMS 获取到的远程 binder 实体，一般会用 **Proxy** 做一层封装，比如 ServiceManagerProxy、 AIDL 生成的 Proxy 类。而被封装的远程 binder 实体是一个 **BinderProxy**。
- **BpBinder** 和 BinderProxy 其实是一个东西，都是远程 binder 实体。只不过BpBinder在 Native 层、BinderProxy在 Java 层。BpBinder 内部持有了一个 binder 句柄值 handle。
- **ProcessState** 是进程单例，负责打开 Binder 驱动设备及 mmap；**IPCThreadState** 为线程单例，负责与 binder 驱动进行具体的命令通信。
- 由 Proxy 发起 transact() 调用，会将数据打包到 Parcel 中，层层向下调用到 BpBinder ，在 BpBinder 中调用 IPCThreadState 的 transact() 方法并传入 handle 句柄值，IPCThreadState 再去执行具体的 binder 命令。
- 由 binder 驱动到 Server 的大概流程就是：Server 通过 IPCThreadState 接收到 Client 的请求后，层层向上，最后回调到 **Stub** 的 onTransact() 方法。
- 当然这不代表所有的 IPC 流程，比如 Service Manager 作为一个 Server 时，便没有上层的封装，也没有借助 IPCThreadState，而是初始化后通过 binder_loop() 方法直接与 binder 驱动通信的。

## Binder面试题

### 为什么Android需要采用Binder

- Linux已有进程通信（管道、共享内存、Socket、File）。从效率、安全、模型三个维度进行对比。
- 安卓中需要的是 c/s 模型，管道是 1v1 模型，所以不适用
- 共享内存安全不满足要求，但效率最高
- Socket 效率太低
- File 磁盘读写也不安全
- Binder为每个App分配UID，同时支持实名和匿名，所以安全性最高。

### Binder传输数据的大小限制是多少

- 1M-8K

### 谈谈你对binder的理解

binder 是 Android 中主要的跨进程通信方式，binder 驱动和 service manager 分别相当于网络协议中的路由器和 DNS，并基于 mmap 实现了 IPC 传输数据时只需一次拷贝。

binder 包括 BinderProxy、BpBinder 等各种 Binder 实体，以及对 binder 驱动操作的 ProcessState、IPCThreadState 封装，再加上 binder 驱动内部的结构体、命令处理，整体贯穿 Java、Native 层，涉及用户态、内核态，往上可以说到 Service、AIDL 等，往下可以说到 mmap、binder 驱动设备，是相当庞大、繁琐的一个机制。

